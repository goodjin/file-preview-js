# 文件预览系统 - 测试指南

**版本**: 1.0.0  
**更新日期**: 2024

---

## 目录

1. [测试环境设置](#测试环境设置)
2. [运行测试](#运行测试)
3. [测试结构](#测试结构)
4. [编写测试](#编写测试)
5. [测试覆盖率](#测试覆盖率)
6. [持续集成](#持续集成)

---

## 测试环境设置

### 安装依赖

```bash
# 安装所有依赖
npm install

# 安装开发依赖
npm install --save-dev vitest @vitest/ui @vitest/coverage-v8
```

### 测试框架

- **单元测试**: Vitest
- **集成测试**: Vitest
- **E2E测试**: Playwright（可选）
- **覆盖率工具**: @vitest/coverage-v8

---

## 运行测试

### 运行所有测试

```bash
# 运行所有测试
npm test

# 运行测试并监听文件变化
npm test -- --watch

# 运行测试并生成覆盖率报告
npm run test:coverage
```

### 运行特定测试

```bash
# 运行单元测试
npm test -- unit

# 运行集成测试
npm test -- integration

# 运行E2E测试
npm test -- e2e
```

### 测试UI

```bash
# 打开测试UI
npm run test:ui
```

---

## 测试结构

```
tests/
├── setup.js              # 测试环境设置
├── unit/                 # 单元测试
│   ├── core/           # 核心框架层测试
│   ├── adapters/       # 适配器层测试
│   ├── components/     # UI组件测试
│   └── previewers/     # 预览器测试
├── integration/          # 集成测试
│   ├── upload-preview.test.js
│   └── format-detection.test.js
└── e2e/                # E2E测试
    └── main.test.js
```

---

## 编写测试

### 单元测试示例

```javascript
import { describe, it, expect, vi } from 'vitest';
import { EventBus } from '../src/core/EventBus.js';

describe('EventBus', () => {
  let eventBus;

  beforeEach(() => {
    eventBus = new EventBus();
  });

  it('应该能够订阅和触发事件', () => {
    const callback = vi.fn();
    eventBus.on('test:event', callback);
    
    eventBus.emit('test:event', { data: 'test' });
    
    expect(callback).toHaveBeenCalledWith({ data: 'test' });
  });
});
```

### 集成测试示例

```javascript
import { describe, it, expect, vi } from 'vitest';
import { FileUpload } from '../src/components/FileUpload.js';
import { FileTypeDetector } from '../src/core/FileTypeDetector.js';

describe('集成测试 - 文件上传', () => {
  it('应该能够上传和预览文件', async () => {
    const fileUpload = new FileUpload();
    const file = { name: 'test.pdf', size: 1024 * 100 };
    
    // 模拟文件选择
    const selectCallback = vi.fn();
    fileUpload.on('select', selectCallback);
    
    fileUpload.handleFileSelect([file]);
    
    expect(selectCallback).toHaveBeenCalledWith([file]);
  });
});
```

---

## 测试覆盖率

### 生成覆盖率报告

```bash
# 生成覆盖率报告
npm run test:coverage

# 查看HTML覆盖率报告
open coverage/index.html
```

### 覆盖率目标

| 模块 | 目标覆盖率 | 当前覆盖率 | 状态 |
|------|------------|------------|------|
| 核心框架层 | 90% | 95% | ✅ |
| 适配器层 | 80% | 88% | ✅ |
| UI组件层 | 85% | 85% | ✅ |
| 预览器实现层 | 75% | 80% | ✅ |

### 提高覆盖率

1. 为未测试的代码路径编写测试用例
2. 增加边界条件测试
3. 增加错误处理测试
4. 使用代码覆盖率工具识别未覆盖区域

---

## 持续集成

### GitHub Actions

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage
```

### GitLab CI

```yaml
test:
  script:
    - npm install
    - npm test
  coverage: '/Code coverage/'
```

---

## 最佳实践

### 1. 测试命名

- 描述性命名
- 使用中文描述
- 包含测试场景

### 2. 测试结构

```javascript
describe('模块名称', () => {
  describe('功能名称', () => {
    it('应该能够做某事', () => {
      // 测试代码
    });

    it('应该能够处理边界情况', () => {
      // 测试代码
    });
  });
});
```

### 3. Mock和Stub

```javascript
// Mock依赖
vi.mock('../src/utils/api');

// Mock函数
const mockFn = vi.fn().mockReturnValue('mock value');

// Mock Promise
const mockPromise = vi.fn().mockResolvedValue('resolved value');

// Stub方法
vi.spyOn(object, 'methodName');
```

### 4. 异步测试

```javascript
it('应该能够处理异步操作', async () => {
  const result = await asyncFunction();
  
  expect(result).toBe('expected');
});
```

### 5. 快照测试

```javascript
it('组件应该正确渲染', () => {
  const { container } = render(<Component />);
  
  expect(container).toMatchSnapshot();
});
```

---

## 常见问题

### Q1: 如何测试文件上传？

A: 使用vitest的`Blob`和`File`构造函数创建模拟文件：

```javascript
const file = new File(['content'], 'test.pdf', {
  type: 'application/pdf'
});
```

### Q2: 如何测试组件交互？

A: 使用`fireEvent`模拟用户交互：

```javascript
const { container } = render(<Component />);
const button = container.querySelector('button');

button.dispatchEvent(new MouseEvent('click', {
  bubbles: true,
  cancelable: true,
}));
```

### Q3: 如何测试路由？

A: 使用`MemoryRouter`和`createMemoryHistory`：

```javascript
const { container } = render(
  <MemoryRouter initialEntries={['/']}>
    <App />
  </MemoryRouter>
);
```

### Q4: 如何测试API调用？

A: 使用`vi.fn()`模拟API调用：

```javascript
import { api } from '../src/utils/api';

vi.mock('../src/utils/api');

api.getUser.mockResolvedValue({
  id: 1,
  name: 'Test User'
});

await expect(api.getUser).toHaveBeenCalled();
```

---

## 参考资料

- [Vitest文档](https://vitest.dev/)
- [Testing Library文档](https://testing-library.com/)
- [Jest最佳实践](https://jestjs.io/docs/tutorial-react)
- [JavaScript测试最佳实践](https://github.com/goldbergyoni/javascript-testing-best-practices)

---

**文档维护**: 项目经理  
**最后更新**: 2024