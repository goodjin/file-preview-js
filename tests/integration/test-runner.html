<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDFé›†æˆæµ‹è¯• - ç®€åŒ–ç‰ˆ</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      background: #1e1e1e;
      color: #d4d4d4;
    }
    #console {
      background: #000;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      min-height: 300px;
      max-height: 500px;
      overflow-y: auto;
    }
    .log-entry {
      margin: 5px 0;
      padding: 2px 0;
      border-bottom: 1px solid #333;
    }
    .success { color: #4ec9b0; }
    .error { color: #f48771; }
    .info { color: #9cdcfe; }
    .warning { color: #dcdcaa; }
    button {
      padding: 10px 20px;
      margin: 5px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover { background: #0056b3; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #results {
      background: #2d2d30;
      padding: 15px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <h1>ğŸ§ª PDFé¢„è§ˆå™¨ä¸DocumentAdapteré›†æˆæµ‹è¯•</h1>
  <div>
    <button id="btn-run">â–¶ï¸ è¿è¡Œæµ‹è¯•</button>
    <button id="btn-clear">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
  </div>
  <div id="console"></div>
  <div id="results"></div>
  
  <script type="module">
    // æ¨¡æ‹ŸFileå¯¹è±¡ï¼ˆå› ä¸ºæˆ‘ä»¬åœ¨æµ‹è¯•ç¯å¢ƒä¸­æ— æ³•çœŸå®ä¸Šä¼ æ–‡ä»¶ï¼‰
    function createMockFile(name, size, type, content = '') {
      const buffer = new ArrayBuffer(size);
      if (content && size > 0) {
        const view = new Uint8Array(buffer);
        for (let i = 0; i < Math.min(content.length, size); i++) {
          view[i] = content.charCodeAt(i);
        }
      }
      
      const file = new File([buffer], name, { type });
      Object.defineProperty(file, 'size', { value: size });
      Object.defineProperty(file, 'name', { value: name });
      return file;
    }
    
    // æ€§èƒ½æµ‹é‡
    class PerformanceMetrics {
      constructor() {
        this.metrics = {};
      }
      start(label) {
        this.metrics[label] = {
          startTime: performance.now(),
          endTime: null,
          duration: null
        };
      }
      end(label) {
        if (this.metrics[label]) {
          this.metrics[label].endTime = performance.now();
          this.metrics[label].duration = 
            this.metrics[label].endTime - this.metrics[label].startTime;
        }
      }
      get(label) {
        return this.metrics[label]?.duration || null;
      }
      getAll() {
        const result = {};
        for (const [label, data] of Object.entries(this.metrics)) {
          result[label] = data.duration;
        }
        return result;
      }
    }
    
    // æµ‹è¯•ç»“æœ
    class TestResult {
      constructor() {
        this.results = [];
      }
      add(name, status, message = '', metrics = {}) {
        this.results.push({
          name, status, message, metrics,
          timestamp: new Date().toISOString()
        });
      }
      getSummary() {
        const total = this.results.length;
        const passed = this.results.filter(r => r.status === 'pass').length;
        const failed = this.results.filter(r => r.status === 'fail').length;
        return { total, passed, failed, 
          passRate: total > 0 ? ((passed / total) * 100).toFixed(2) + '%' : '0%' };
      }
    }
    
    // æ—¥å¿—å·¥å…·
    function log(message, type = 'info') {
      const consoleDiv = document.getElementById('console');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      consoleDiv.appendChild(entry);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }
    
    // å¯¼å…¥é€‚é…å™¨å’Œé¢„è§ˆå™¨
    let DocumentAdapter, PDFPreviewerModule;
    
    async function loadModules() {
      try {
        // è¿™é‡Œæˆ‘ä»¬éœ€è¦æ ¹æ®å®é™…çš„æ¨¡å—è·¯å¾„è°ƒæ•´
        // ç”±äºæˆ‘ä»¬åœ¨å·¥ä½œç©ºé—´ä¸­ï¼Œä½¿ç”¨ç›¸å¯¹è·¯å¾„
        const adapterModule = await import('../../src/adapters/DocumentAdapter.js');
        DocumentAdapter = adapterModule.default;
        
        const pdfModule = await import('../../src/implementations/document/pdf/index.js');
        PDFPreviewerModule = pdfModule;
        
        log('æ¨¡å—åŠ è½½æˆåŠŸ', 'success');
        return true;
      } catch (error) {
        log(`æ¨¡å—åŠ è½½å¤±è´¥: ${error.message}`, 'error');
        log('è¿™æ˜¯é¢„æœŸçš„ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨æµ‹è¯•ç¯å¢ƒä¸­', 'warning');
        return false;
      }
    }
    
    // æµ‹è¯•1: æ–‡ä»¶ç±»å‹æ£€æµ‹
    async function testFileTypeDetection() {
      log('ğŸ§ª æµ‹è¯•1: æ–‡ä»¶ç±»å‹æ£€æµ‹', 'info');
      
      const adapter = new DocumentAdapter();
      const testCases = [
        { name: 'test.pdf', expected: 'pdf' },
        { name: 'document.PDF', expected: 'pdf' },
        { name: 'test.txt', expected: 'txt' },
        { name: 'test.jpg', expected: 'jpg' }
      ];
      
      for (const testCase of testCases) {
        const ext = adapter.getFileExtension(testCase.name);
        if (ext === testCase.expected) {
          log(`  âœ… ${testCase.name} â†’ ${ext}`, 'success');
        } else {
          log(`  âŒ ${testCase.name} æœŸæœ› ${testCase.expected}, å®é™… ${ext}`, 'error');
        }
      }
    }
    
    // æµ‹è¯•2: DocumentAdapterè§£æ
    async function testDocumentAdapterParse() {
      log('ğŸ§ª æµ‹è¯•2: DocumentAdapterè§£æPDF', 'info');
      
      const adapter = new DocumentAdapter();
      const pdfFile = createMockFile('test.pdf', 1024 * 100, 'application/pdf', '%PDF-1.4');
      
      try {
        const result = await adapter.parse(pdfFile);
        log(`  âœ… è§£ææˆåŠŸ: ${result.fileName}`, 'success');
        log(`     ç±»å‹: ${result.fileType}, å¤§å°: ${result.fileSize}`, 'info');
        log(`     æ•°æ®ç±»å‹: ${typeof result.data}`, 'info');
        log(`     æ•°æ®å¤§å°: ${result.data ? result.data.byteLength : 0} bytes`, 'info');
      } catch (error) {
        log(`  âŒ è§£æå¤±è´¥: ${error.message}`, 'error');
      }
    }
    
    // æµ‹è¯•3: æ–‡ä»¶ç±»å‹æ”¯æŒæ£€æŸ¥
    async function testSupportedTypes() {
      log('ğŸ§ª æµ‹è¯•3: æ”¯æŒçš„æ–‡ä»¶ç±»å‹', 'info');
      
      const adapter = new DocumentAdapter();
      const supportedTypes = adapter.getSupportedTypes();
      
      log(`  æ”¯æŒçš„ç±»å‹: ${supportedTypes.join(', ')}`, 'info');
      
      if (supportedTypes.includes('pdf')) {
        log(`  âœ… PDFç±»å‹å·²æ”¯æŒ`, 'success');
      } else {
        log(`  âŒ PDFç±»å‹æœªæ”¯æŒ`, 'error');
      }
    }
    
    // æµ‹è¯•4: canHandleæ–¹æ³•
    async function testCanHandle() {
      log('ğŸ§ª æµ‹è¯•4: canHandleæ–¹æ³•', 'info');
      
      const adapter = new DocumentAdapter();
      const types = ['pdf', 'txt', 'md', 'json', 'xml', 'docx', 'jpg'];
      
      for (const type of types) {
        const canHandle = adapter.canHandle(type);
        const status = canHandle ? 'âœ…' : 'âŒ';
        log(`  ${status} ${type}: ${canHandle}`, canHandle ? 'success' : 'info');
      }
    }
    
    // æµ‹è¯•5: é”™è¯¯å¤„ç† - ä¸æ”¯æŒçš„ç±»å‹
    async function testUnsupportedType() {
      log('ğŸ§ª æµ‹è¯•5: ä¸æ”¯æŒçš„ç±»å‹å¤„ç†', 'info');
      
      const adapter = new DocumentAdapter();
      const unsupportedFile = createMockFile('test.docx', 1024, 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
      
      try {
        const result = await adapter.parse(unsupportedFile);
        log(`  âŒ åº”è¯¥æ‹’ç»ä½†æœªæ‹’ç»`, 'error');
      } catch (error) {
        log(`  âœ… æ­£ç¡®æ‹’ç»: ${error.message}`, 'success');
      }
    }
    
    // è¿è¡Œæ‰€æœ‰æµ‹è¯•
    async function runAllTests() {
      const btnRun = document.getElementById('btn-run');
      btnRun.disabled = true;
      
      document.getElementById('console').innerHTML = '';
      log('='.repeat(50), 'info');
      log('å¼€å§‹æ‰§è¡Œé›†æˆæµ‹è¯•', 'info');
      log('='.repeat(50), 'info');
      
      const modulesLoaded = await loadModules();
      
      if (modulesLoaded && DocumentAdapter) {
        log('', 'info');
        await testFileTypeDetection();
        log('', 'info');
        await testDocumentAdapterParse();
        log('', 'info');
        await testSupportedTypes();
        log('', 'info');
        await testCanHandle();
        log('', 'info');
        await testUnsupportedType();
      } else {
        log('', 'info');
        log('âš ï¸ æ¨¡å—æœªåŠ è½½ï¼Œè·³è¿‡å®é™…æµ‹è¯•', 'warning');
        log('   åœ¨å®é™…ç¯å¢ƒä¸­éœ€è¦:', 'info');
        log('   1. æ­£ç¡®çš„æ¨¡å—è·¯å¾„', 'info');
        log('   2. PDF.jsåº“çš„åŠ è½½', 'info');
        log('   3. æµè§ˆå™¨ç¯å¢ƒæ”¯æŒ', 'info');
      }
      
      log('', 'info');
      log('='.repeat(50), 'info');
      log('æµ‹è¯•å®Œæˆ', 'info');
      log('='.repeat(50), 'info');
      
      // æ˜¾ç¤ºç»“æœæ‘˜è¦
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = `
        <h3>æµ‹è¯•æ‘˜è¦</h3>
        <p>ç”±äºæµ‹è¯•ç¯å¢ƒçš„é™åˆ¶ï¼Œæœ¬æµ‹è¯•ä¸»è¦éªŒè¯DocumentAdapterçš„åŸºæœ¬åŠŸèƒ½ã€‚</p>
        <p><strong>æ³¨æ„:</strong> å®Œæ•´çš„é›†æˆæµ‹è¯•éœ€è¦åœ¨å®é™…çš„æµè§ˆå™¨ç¯å¢ƒä¸­è¿è¡Œï¼Œ</p>
        <p>å¹¶ä½¿ç”¨çœŸå®çš„PDF.jsåº“å’ŒPDFæ–‡ä»¶è¿›è¡Œæµ‹è¯•ã€‚</p>
        <p>æµ‹è¯•æ–‡ä»¶ä½ç½®:</p>
        <ul>
          <li>æµ‹è¯•ä»£ç : tests/integration/pdf-document-adapter-integration.test.js</li>
          <li>æµ‹è¯•è¿è¡Œå™¨: tests/integration/runner.html</li>
          <li>æµ‹è¯•è®¡åˆ’: docs/pdf-document-adapter-integration-test-plan.md</li>
        </ul>
      `;
      
      btnRun.disabled = false;
    }
    
    // äº‹ä»¶ç»‘å®š
    document.getElementById('btn-run').addEventListener('click', runAllTests);
    document.getElementById('btn-clear').addEventListener('click', () => {
      document.getElementById('console').innerHTML = '';
    });
    
    // è‡ªåŠ¨è¿è¡Œ
    setTimeout(runAllTests, 500);
  </script>
</body>
</html>
