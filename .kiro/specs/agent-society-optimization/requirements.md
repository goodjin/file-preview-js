# 需求文档

## 简介

本文档定义了自组织AI Agent社会系统的优化和下一步开发需求。基于当前系统已实现的基础能力（组织构建原语、异步消息通道、工件存储、提示词加载、LLM工具调用循环），本次迭代聚焦于：支持长期运行（HTTP服务）、修复用户端点消息流转问题、完善智能体生命周期管理、提升系统稳定性与可观测性。

## 术语表

- **Runtime**: 运行时，负责将平台能力与智能体行为连接起来的核心组件
- **Agent_Instance**: 智能体实例，某岗位模板在某任务场景中的一次运行实体
- **Role**: 岗位，定义职责、能力边界、输入输出标准的模板
- **Message_Bus**: 消息总线，负责异步消息的发送、投递、接收与排队
- **User_Endpoint**: 用户端点，一个纯代码驱动的伪智能体（id="user"），代表真实用户在系统中的位置。它具有智能体身份，可以调用智能体之间的异步消息接口。用户发往此端点的消息必须携带目标智能体ID（可以是root或其他智能体ID，但不能是"user"），User_Endpoint会将消息转发到目标智能体。任何智能体可以通过to="user"向用户端点发送消息，这些消息最终会呈现给真实用户（当前通过控制台打印，后续可扩展为HTTP响应等形式）
- **Terminate_Tool**: 终止工具，用于智能体实例的终止与资源回收

## 需求

### 需求 1: 用户端点消息流转修复

**用户故事:** 作为系统架构师，我希望用户端点的消息流转逻辑清晰正确，以便消息不会出现from=user to=user的混乱情况。

#### 验收标准

1. 当真实用户发送消息时，必须携带目标智能体ID（可以是root或其他智能体ID，但不能是"user"）
2. 当真实用户发送消息时，User_Endpoint应直接调用send_message发送到目标智能体，from字段设为"user"，不应先发送给自己
3. 当组织内智能体向用户回复时（to="user"），User_Endpoint应接收该消息并呈现给真实用户
4. 如果用户尝试发送消息到"user"，User_Endpoint应拒绝并返回错误提示
5. User_Endpoint的消息呈现方式应支持控制台输出，后续可扩展为HTTP响应

### 需求 2: HTTP服务支持长期运行

**用户故事:** 作为用户，我希望系统提供HTTP服务接口，以便我可以通过Web方式与系统长期交互。

#### 验收标准

1. 当系统启动时，Runtime应启动一个HTTP服务器监听指定端口（默认3000）
2. 当用户通过POST /api/submit发送需求时，HTTP_Server应调用User_Endpoint将需求转发给根智能体并返回taskId
3. 当用户通过POST /api/send发送消息时，HTTP_Server应调用User_Endpoint将消息发送到指定智能体（必须携带agentId参数）
4. 当用户通过GET /api/messages/{taskId}查询时，HTTP_Server应返回该任务的所有用户收到的消息
5. 当HTTP服务器启动失败时，Runtime应记录错误并继续以控制台模式运行
6. HTTP_Server应支持配置文件中指定端口号

### 需求 3: 智能体实例终止与回收

**用户故事:** 作为系统运维人员，我希望智能体能被正确终止并回收资源，以便系统长期运行时不会内存泄漏。

#### 验收标准

1. 当父智能体调用terminate_agent工具并传入子智能体ID时，Runtime应将该子智能体从活跃智能体注册表中移除
2. 当智能体被终止时，Runtime应清理其会话上下文以释放内存
3. 当智能体被终止时，Runtime应将终止事件持久化到组织状态
4. 如果非父智能体尝试终止某智能体，Runtime应拒绝请求并返回错误
5. 当智能体被终止时，Runtime应先处理完其队列中的待处理消息再移除

### 需求 4: 会话上下文管理

**用户故事:** 作为系统架构师，我希望会话上下文能被高效管理，智能体能自主判断上下文过长的原因并采取相应措施，以便系统长期稳定运行。

#### 验收标准

1. Runtime应提供compress_context工具，允许智能体主动压缩较久远的历史信息，只保留重要内容和最新上下文
2. 当智能体调用compress_context时，Runtime应保留系统提示词、最近N条消息（可配置）以及智能体指定的重要内容摘要
3. Runtime应提供可配置的max_context_messages参数（默认50条），当超过时向智能体发出警告
4. 智能体的岗位提示词应包含上下文管理指导：当感知到上下文过长时，需自行判断原因并采取措施
5. 如果上下文过长是因为职责太多导致的复杂，智能体应创建下级岗位和智能体分担责任
6. 如果上下文过长是因为经手业务量太大，智能体应向父级智能体申请增加同等岗位的智能体分担业务
7. 如果上下文过长是因为简单重复工作累积的历史信息，智能体应调用compress_context工具压缩历史记录

### 需求 5: 错误恢复与容错

**用户故事:** 作为系统运维人员，我希望系统能优雅地处理错误，以便单个故障不会导致整个系统崩溃。

#### 验收标准

1. 如果LLM调用失败，Runtime应使用指数退避策略重试（最多3次）
2. 如果智能体的消息处理器抛出异常，Runtime应记录错误并继续处理其他智能体
3. 当智能体超过最大工具调用轮次限制时，Runtime应向父智能体发送错误通知
4. 如果工具调用返回错误，Runtime应将错误包含在会话上下文中供LLM处理

### 需求 6: 可观测性增强

**用户故事:** 作为系统运维人员，我希望有全面的可观测性，以便我能监控系统健康状况并调试问题。

#### 验收标准

1. Logger应记录智能体生命周期事件（创建、终止、收到消息、发送消息）
2. Logger应记录LLM调用指标（延迟、token数量、成功/失败）
3. Runtime应暴露一个方法来列出所有活跃智能体及其状态
4. Runtime应跟踪并记录每个智能体的队列深度
5. 当智能体空闲超过可配置的时长时，Logger应发出警告

### 需求 7: 组织状态一致性

**用户故事:** 作为系统架构师，我希望组织状态保持一致，以便系统重启后行为可预测。

#### 验收标准

1. 当创建岗位或智能体时，Org_Primitives应原子性地持久化变更
2. 当加载组织状态时，Org_Primitives应验证数据结构
3. 如果组织状态损坏，Org_Primitives应记录错误并以空状态启动
4. Org_Primitives应支持列出所有岗位和智能体以便调试

### 需求 8: 优雅关闭

**用户故事:** 作为系统运维人员，我希望系统能优雅关闭，以便不会丢失正在处理的任务。

#### 验收标准

1. 当收到SIGINT或SIGTERM信号时，Runtime应停止接收新消息
2. 当关闭时，Runtime应等待当前正在处理的消息完成（最多30秒超时）
3. 当关闭时，Runtime应持久化所有智能体的当前状态
4. 当关闭完成时，Runtime应记录关闭摘要（处理了多少消息、有多少待处理）

