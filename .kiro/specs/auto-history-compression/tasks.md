# 自动历史消息压缩功能 - 任务列表

## 1. ConversationManager 扩展

- [x] 1.1 添加自动压缩配置项 ✅ 已完成
  - 在构造函数中添加 `autoCompression` 配置对象
  - 设置默认值：enabled=true, threshold=0.8, keepRecentCount=10 等
  - summaryModel 默认为 null，必须由用户配置
  - 添加配置验证逻辑
  - 已通过 AutoCompressionManager 实现
  - [x] 1.1.1 编写单元测试：测试配置项初始化 ✅
  - [x] 1.1.2 编写单元测试：测试配置项默认值 ✅
  - [x] 1.1.3 编写单元测试：测试配置项验证逻辑 ✅

- [x] 1.2 实现自动压缩核心逻辑 ✅ 已完成
  - 已通过 AutoCompressionManager 实现以下内部方法：
    - shouldAutoCompress(): 检查是否应该触发自动压缩
    - generateCompressionSummary(): 通过 LLM 生成压缩摘要
    - _buildSummaryPrompt(): 构建摘要生成提示词
  - 这些方法不暴露给 ConversationManager 外部，仅供内部使用
  - [x] 1.2.1 编写单元测试：自动压缩禁用时返回 false ✅
  - [x] 1.2.2 编写单元测试：未配置模型时返回 false ✅
  - [x] 1.2.3 编写单元测试：达到阈值时返回 true ✅
  - [x] 1.2.4 编写单元测试：未达到阈值时返回 false ✅
  - [x] 1.2.5 编写单元测试：测试消息格式化 ✅
  - [x] 1.2.6 编写单元测试：测试提示词结构 ✅
  - [x] 1.2.7 编写单元测试：测试不同角色消息的处理 ✅
  - [x] 1.2.8 编写单元测试：未配置模型时返回错误 ✅
  - [x] 1.2.9 编写单元测试：成功生成摘要 ✅
  - [x] 1.2.10 编写单元测试：LLM 调用失败时返回错误 ✅
  - [x] 1.2.11 编写单元测试：空摘要时返回错误 ✅
  - [x] 1.2.12 编写单元测试：超时处理 ✅

- [ ] 1.3 修改 compress() 方法
  - 初始化完整历史存储（_fullHistory）
  - 初始化压缩历史存储（_compressionHistory）
  - 保存完整历史消息（不受压缩影响）
  - 记录压缩信息（时间戳、摘要、压缩范围、原始消息）
  - 创建运行时压缩后的消息
  - 返回压缩结果
  - [ ] 1.3.1 编写单元测试：第一次压缩时初始化完整历史
  - [ ] 1.3.2 编写单元测试：压缩后运行时消息正确
  - [ ] 1.3.3 编写单元测试：完整历史保持不变
  - [ ] 1.3.4 编写单元测试：压缩记录正确保存
  - [ ] 1.3.5 编写单元测试：多次压缩的累积记录
  - [ ] 1.3.6 编写单元测试：消息不足时不压缩

- [ ] 1.4 实现内部 _autoCompress() 方法（供 LlmHandler 调用）
  - 提取需要压缩的消息
  - 调用 generateCompressionSummary() 生成摘要
  - 摘要生成失败时返回错误，不执行压缩
  - 摘要生成成功时调用 compress() 执行压缩
  - 返回压缩结果
  - [ ] 1.4.1 编写单元测试：消息不足时不压缩
  - [ ] 1.4.2 编写单元测试：摘要生成失败时不压缩
  - [ ] 1.4.3 编写单元测试：成功执行自动压缩
  - [ ] 1.4.4 编写单元测试：验证压缩结果

- [ ] 1.5 修改 _doSaveConversation() 方法
  - 保存完整历史消息（messages）
  - 保存运行时压缩后的消息（runtimeMessages）
  - 保存压缩记录列表（compressions）
  - 保存 token 使用统计
  - 记录更新时间
  - [ ] 1.5.1 编写单元测试：保存未压缩的对话
  - [ ] 1.5.2 编写单元测试：保存压缩后的对话
  - [ ] 1.5.3 编写单元测试：验证持久化数据结构
  - [ ] 1.5.4 编写单元测试：验证完整历史和运行时消息分离

- [ ] 1.6 修改 loadAllConversations() 方法
  - 加载完整历史消息
  - 加载运行时消息（如果有压缩）
  - 恢复压缩记录
  - 恢复 token 使用统计
  - 兼容旧格式数据
  - [ ] 1.6.1 编写单元测试：加载未压缩的对话
  - [ ] 1.6.2 编写单元测试：加载压缩后的对话
  - [ ] 1.6.3 编写单元测试：恢复完整历史和压缩记录
  - [ ] 1.6.4 编写单元测试：兼容旧格式数据
  - [ ] 1.6.5 编写单元测试：处理损坏的数据文件

- [ ] 1.7 实现 getCompressionHistory() 方法
  - 返回智能体的压缩历史记录列表
  - [ ] 1.7.1 编写单元测试：无压缩记录时返回空数组
  - [ ] 1.7.2 编写单元测试：返回正确的压缩记录

- [ ] 1.8 实现 getFullHistory() 方法
  - 返回智能体的完整历史消息（未压缩）
  - [ ] 1.8.1 编写单元测试：无完整历史时返回 null
  - [ ] 1.8.2 编写单元测试：返回正确的完整历史

- [ ] 1.9 实现 setAutoCompressionConfig() 方法（可选）
  - 接收配置对象
  - 委托给 AutoCompressionManager.updateConfig()
  - [ ] 1.9.1 编写单元测试：部分更新配置
  - [ ] 1.9.2 编写单元测试：验证配置有效性
  - [ ] 1.9.3 编写单元测试：无效配置时抛出错误

- [ ] 1.10 实现 getAutoCompressionConfig() 方法（可选）
  - 返回当前自动压缩配置
  - 委托给 AutoCompressionManager.getConfig()
  - [ ] 1.10.1 编写单元测试：返回正确的配置对象

## 2. LlmHandler 扩展

- [ ] 2.1 修改 handleWithLlm() 方法
  - 在 LLM 调用前添加自动压缩检查
  - 调用 shouldAutoCompress() 判断是否需要压缩
  - 需要压缩时调用 _performAutoCompression()
  - 检查上下文硬性限制
  - 超过硬性限制时调用 _truncateMessageHistory()
  - 保持现有流程不变

- [ ] 2.2 实现 _performAutoCompression() 方法
  - 记录压缩前的状态（token 使用率、消息数量）
  - 调用 ConversationManager.autoCompress()
  - 摘要生成失败时记录警告日志，不执行压缩
  - 压缩成功时记录压缩后的状态
  - 清除 token 使用统计
  - 触发对话持久化
  - 处理压缩异常情况

- [ ] 2.3 实现 _truncateMessageHistory() 方法
  - 获取对话历史
  - 保留系统提示词和最近的消息
  - 删除中间的消息
  - 更新对话历史
  - 清除 token 使用统计
  - 记录截断日志
  - 触发对话持久化

## 3. 日志和监控

- [ ] 3.1 添加自动压缩触发日志
  - 记录触发时的上下文状态
  - 记录触发原因和阈值

- [ ] 3.2 添加摘要生成日志
  - 记录 LLM 调用信息
  - 记录摘要生成耗时
  - 记录摘要长度

- [ ] 3.3 添加压缩完成日志
  - 记录压缩前后的消息数量
  - 记录压缩前后的 token 使用情况
  - 记录压缩结果

- [ ] 3.4 添加错误和警告日志
  - 记录摘要生成失败
  - 记录压缩执行失败
  - 记录消息历史截断
  - 记录压缩异常

## 4. 配置管理

- [ ] 4.1 在 config/app.json 中添加配置示例
  - 添加 conversation.autoCompression 配置节
  - 提供默认配置值
  - **必须配置 summaryModel**（如 "gpt-4o-mini"）
  - 添加配置说明注释

- [ ] 4.2 在 config.js 中加载自动压缩配置
  - 读取配置文件中的自动压缩配置
  - 验证 summaryModel 是否已配置
  - 传递给 ConversationManager 构造函数
  - 处理配置缺失情况

## 5. 测试

- [ ] 5.1 编写 ConversationManager 单元测试
  - [ ] 5.1.1 测试 shouldAutoCompress() 方法
  - [ ] 5.1.2 测试 _buildSummaryPrompt() 方法
  - [ ] 5.1.3 测试 generateCompressionSummary() 方法
  - [ ] 5.1.4 测试 autoCompress() 方法
  - [ ] 5.1.5 测试 compress() 方法（完整历史保留）
  - [ ] 5.1.6 测试持久化方法（完整历史和压缩记录）
  - [ ] 5.1.7 测试加载方法（恢复完整历史和压缩记录）
  - [ ] 5.1.8 测试 getCompressionHistory() 方法
  - [ ] 5.1.9 测试 getFullHistory() 方法
  - [ ] 5.1.10 测试配置管理方法

- [ ] 5.2 编写 LlmHandler 单元测试
  - [ ] 5.2.1 测试自动压缩触发逻辑
  - [ ] 5.2.2 测试 _performAutoCompression() 方法
  - [ ] 5.2.3 测试摘要生成失败时不执行压缩
  - [ ] 5.2.4 测试 _truncateMessageHistory() 方法
  - [ ] 5.2.5 测试硬性限制截断逻辑

- [ ] 5.3 编写集成测试
  - [ ] 5.3.1 测试完整的自动压缩流程
  - [ ] 5.3.2 测试摘要生成失败后的硬性限制截断
  - [ ] 5.3.3 测试自动压缩和手动压缩共存
  - [ ] 5.3.4 测试多个智能体的自动压缩
  - [ ] 5.3.5 测试持久化和加载（完整历史保留）
  - [ ] 5.3.6 测试压缩记录的可展开查看

- [ ] 5.4 编写性能测试
  - [ ] 5.4.1 测试摘要生成耗时
  - [ ] 5.4.2 测试自动压缩对 LLM 调用的影响

## 6. 文档

- [ ] 6.1 更新 ConversationManager 文档
  - 添加自动压缩功能说明
  - 添加新增方法的文档
  - 添加配置项说明

- [ ] 6.2 更新 LlmHandler 文档
  - 添加自动压缩集成说明
  - 添加流程图

- [ ] 6.3 编写用户指南
  - 自动压缩功能介绍
  - 配置说明
  - 常见问题解答

- [ ] 6.4 编写开发者指南
  - API 接口文档
  - 扩展指南
  - 故障排查指南

## 7. 优化和完善

- [ ] 7.1 性能优化
  - 优化摘要生成提示词
  - 优化压缩时机判断
  - 添加摘要缓存（可选）

- [ ] 7.2 错误处理优化
  - 完善错误分类
  - 优化摘要生成失败的处理
  - 优化硬性限制截断策略
  - 添加重试机制（可选）

- [ ] 7.3 监控优化
  - 添加压缩统计指标
  - 添加性能监控
  - 添加告警机制

## 8. UI 展示（可选）

- [ ] 8.1 设计压缩历史展示组件
  - 设计压缩点标记样式
  - 设计摘要展示样式
  - 设计展开/折叠交互

- [ ] 8.2 实现压缩历史展示功能
  - 在对话历史中标记压缩点
  - 显示压缩摘要
  - 实现展开查看完整消息
  - 显示压缩时间和统计信息

- [ ] 8.3 实现多层压缩展示
  - 支持多次压缩的层级展示
  - 提供导航功能
  - 优化大量压缩时的性能

## 任务优先级

### 高优先级（必须完成）
- 1.1 - 1.8: ConversationManager 核心功能（包括持久化）
- 2.1 - 2.3: LlmHandler 集成（包括截断逻辑）
- 3.1 - 3.4: 日志记录
- 4.1 - 4.2: 配置管理（包括 summaryModel 配置）
- 5.1 - 5.2: 单元测试

### 中优先级（建议完成）
- 1.9 - 1.10: 配置管理方法（可选）
- 5.3: 集成测试
- 6.1 - 6.2: 核心文档

### 低优先级（可选完成）
- 5.4: 性能测试
- 6.3 - 6.4: 用户和开发者指南
- 7.1 - 7.3: 优化和完善
- 8.1 - 8.3: UI 展示功能

## 预估工作量

- ConversationManager 扩展: 8-10 小时（包括持久化逻辑）
- LlmHandler 扩展（包括截断逻辑）: 3-4 小时
- 日志和监控: 1-2 小时
- 配置管理: 1-2 小时
- 测试: 6-8 小时（包括持久化测试）
- 文档: 2-3 小时
- 优化和完善: 2-4 小时

总计: 23-33 小时
